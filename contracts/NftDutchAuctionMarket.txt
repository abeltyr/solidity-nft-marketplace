// SPDX-License-Identifier: MIT

pragma solidity ^0.8.4;
import "./interfaces/INftStore.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";

contract NftDutchAuctionMarket {
  using Counters for Counters.Counter;
  using SafeMath for uint256;
  using Math for uint256;
  Counters.Counter private itemCount;

  address private storeAddress;

  constructor(address _storeAddress) {
    storeAddress = _storeAddress;
  }

  struct Auction {
    /// @notice A unique id to identify the auction.
    uint256 id;
    /// @notice Address of the smart-contract of the nft to sell.
    address tokenAddress;
    /// @notice Id of the nft in the smart-contract.
    uint256 tokenId;
    /// @notice The nft seller.
    address seller;
    /// @notice Starting price for the nft.
    uint256 startingPrice;
    /// @notice Ending price for the nft.
    uint256 endingPrice;
    /// @notice Date to start selling.
    uint256 startDate;
    /// @notice Date to stop selling.
    uint256 endDate;
    /// @notice The interval at which the price should decrease.
    uint256 timeInterval;
    /// @notice Date at which the auction is closed.
    /// @dev Is null initially.
    uint256 closeDate;
    /// @notice The address of the buyer.
    /// @dev Is null initially.
    address buyer;
    /// @notice The price at which the nft is sold.
    /// @dev Is null initially.
    uint256 salePrice;
  }

  // @dev Emitted when an auction is closed by any mechanism.
  event Close(uint256 auctionId);

  // AuctionId -> Auction
  mapping(uint256 => Auction) public Auctions;

  // list item to offer on the NFTListingMarket
  function list(
    address tokenAddress,
    uint256 tokenId,
    uint256 startingPrice,
    uint256 endingPrice,
    uint256 timeInterval,
    uint256 startDate,
    uint256 endDate
  ) external {
    INftStore _store = INftStore(storeAddress);

    if (startDate == 0) {
      startDate = block.timestamp;
    } else {
      require(startDate >= block.timestamp, "startDate is in the past");
    }

    require(endDate > startDate, "endDate is older then startDate");
    require(
      startingPrice > endingPrice,
      "starting price is less then end price"
    );

    require(startingPrice > 0, "Price must be greater than zero");

    // reserve nft
    _store.reserve(IERC721(tokenAddress), tokenId, msg.sender);

    itemCount.increment();

    uint256 itemId = itemCount.current();

    // following values are null initially
    uint256 closeDate = 0;
    uint256 salePrice = 0;
    address buyer = address(0);

    Auction memory _auction = Auction({
      id: itemId,
      tokenAddress: tokenAddress,
      tokenId: tokenId,
      seller: payable(msg.sender),
      startingPrice: startingPrice,
      endingPrice: endingPrice,
      startDate: startDate,
      endDate: endDate,
      timeInterval: timeInterval,
      closeDate: closeDate,
      buyer: buyer,
      salePrice: salePrice
    });
    Auctions[itemId] = _auction;

    _store.list(IERC721(tokenAddress), tokenId, _auction.id);
  }

  //interface price of function using external but its not possible because we need result of price of function in buy function
  function priceOf(uint256 auctionId) public view returns (uint256) {
    Auction storage auction = Auctions[auctionId];
    if (auction.endDate > block.timestamp) {
      return auction.endingPrice;
    }
    uint256 dateDiffrence = SafeMath.sub(auction.endDate, auction.startDate);
    uint256 totalInterval = SafeMath.div(dateDiffrence, (auction.timeInterval));
    uint256 priceVariation = SafeMath.sub(
      auction.endingPrice,
      auction.startingPrice
    );

    uint256 currentdateDifference = SafeMath.sub(
      block.timestamp,
      auction.startDate
    );

    uint256 completedInterval = SafeMath.div(
      currentdateDifference,
      totalInterval
    );
    uint256 ratio = SafeMath.div(completedInterval, totalInterval);
    uint256 completion = Math.min(ratio, 1);

    uint256 totalPricevariation = SafeMath.add(
      auction.startingPrice,
      priceVariation
    );
    uint256 price = SafeMath.mul(totalPricevariation, completion);
    //  uint256 price = auction.startingPrice + priceVariation * completion;
    return currentdateDifference;
  }

  function buy(uint256 auctionId) external payable {
    require(auctionId > 0 && auctionId <= itemCount.current(), "doesn't exist");
    Auction storage auction = Auctions[auctionId];
    uint256 nftPrice = priceOf(auctionId);
    require(msg.value >= nftPrice, "not enough ether");
    // require(auction.buyer != address(0), "already sold");

    INftStore _store = INftStore(storeAddress);

    _store.unlist(IERC721(auction.tokenAddress), auction.tokenId, auction.id);

    _store.clear(IERC721(auction.tokenAddress), auction.tokenId);

    _store.release(IERC721(auction.tokenAddress), auction.tokenId, msg.sender);

    payable(auction.seller).transfer(auction.salePrice);

    // update the buyer info, Set closeDate, salePrice and buyer and emits Close.
    auction.buyer = msg.sender;
    auction.closeDate = block.timestamp;
    auction.salePrice = nftPrice;
    emit Close(auction.id);
  }

  function cancel(uint256 auctionId) external {
    Auction storage auction = Auctions[auctionId];

    auction.buyer = msg.sender;
    auction.closeDate = block.timestamp;
    emit Close(auction.id);
  }
}
